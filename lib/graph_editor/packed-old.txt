class GraphCommand {
  String version = Uuid().v1().toString();
  String target;

  static GraphCommand none = GraphCommand();
  String get name => "none";

  GraphCommand();

  factory GraphCommand.chart(TideChartCommand cmd) {
    GraphCommand result;

    switch (cmd.whichCommand()) {
      case TideChartCommand_Command.group:
        result = GraphCommandGroup.chart(cmd.group);
        break;
      case TideChartCommand_Command.move:
        result = GraphMoveCommand.chart(cmd.move);
        break;

      case TideChartCommand_Command.link:
        result = GraphLinkCommand.chart(cmd.link);
        break;
      case TideChartCommand_Command.node:
        result = GraphNodeCommand.chart(cmd.node);
        break;

      default:
        result = GraphCommand();
        break;
    }

    result.version = cmd.version;
    result.target = cmd.target;
    return result;
  }

  GraphCommand get reverse {
    return GraphCommand.none;
  }

  Map<String, dynamic> toJson() => {
        'version': version,
        'target': target,
        'name': name,
      };

  TideChartCommand toChart() {
    TideChartCommand result = TideChartCommand();
    if (version != null) result.version = version;
    if (target != null) result.target = target;
    return result;
  }

  TideChartCommandUpdateType toUpdateType(String type) {
    switch (type) {
      case "add":
        return TideChartCommandUpdateType.add;
      case "remove":
        return TideChartCommandUpdateType.remove;
      case "update":
        return TideChartCommandUpdateType.update;
    }

    return null;
  }
}

class GraphCommandGroup extends GraphCommand {
  List<GraphCommand> cmds = [];
  @override
  String get name => "group";

  bool get isNotEmpty => cmds.isNotEmpty;
  bool get isEmpty => cmds.isEmpty;
  int get length => cmds.length;

  GraphCommandGroup();
  GraphCommandGroup.chart(TideChartGroupCommand group) {
    cmds = group.commands.map((x) => GraphCommand.chart(x));
  }

  GraphCommandGroup.all(Iterable<GraphCommand> source) {
    cmds = [...source];
  }

  GraphCommandGroup.moveAll(Iterable<GraphNode> nodes) {
    cmds = [...nodes.map((x) => GraphMoveCommand.node(x))];
  }

  void add(GraphCommand cmd) {
    cmds.add(cmd);
  }

  void addAll(Iterable<GraphCommand> source) {
    cmds.addAll(source);
  }

  void clear() {
    cmds.clear();
  }

  Map<String, dynamic> toJson() {
    var result = super.toJson();
    result.addAll({"cmds": cmds});
    return result;
  }

  @override
  TideChartCommand toChart() {
    TideChartCommand result = super.toChart();

    result.group = TideChartGroupCommand()
      ..commands.addAll(cmds.map((x) => x.toChart()));

    return result;
  }

  @override
  GraphCommand get reverse {
    return GraphCommandGroup.all(cmds.map((x) => x.reverse))..version = version;
  }
}

class GraphMoveCommand extends GraphCommand {
  RefGraphNode node;
  Offset fromPos = Offset.zero;
  Offset toPos = Offset.zero;

  GraphMoveCommand();
  GraphMoveCommand.chart(TideChartMoveCommand move) {
    node = RefGraphNode()..name = move.node;
    fromPos = Offset(move.fromPosX.toDouble(), move.fromPosY.toDouble());
    toPos = Offset(move.toPosX.toDouble(), move.toPosY.toDouble());
  }

  GraphMoveCommand.node(GraphNode node) {
    this.node = node.ref();
    this.fromPos = node.dragStart;
    this.toPos = node.pos;
  }

  @override
  String get name => "move";

  @override
  GraphCommand get reverse {
    return GraphMoveCommand()
      ..node = node
      ..fromPos = toPos
      ..toPos = fromPos
      ..version = version;
  }

  Map<String, dynamic> toJson() {
    var result = super.toJson();
    result.addAll({
      "node": node.name,
      "fromPos": [fromPos.dx, fromPos.dy],
      "toPos": [toPos.dx, toPos.dy],
    });

    return result;
  }

  @override
  TideChartCommand toChart() {
    TideChartCommand result = super.toChart();
    result.move = TideChartMoveCommand()
      ..node = node.name
      ..fromPosX = fromPos.dx.round()
      ..fromPosY = fromPos.dy.round()
      ..toPosX = toPos.dx.round()
      ..toPosY = toPos.dy.round();

    return result;
  }
}

class GraphNodeCommand extends GraphCommand {
  String type;

  PackedGraphNode node;
  PackedGraphNode last;

  GraphNodeCommand();

  GraphNodeCommand.chart(TideChartNodeCommand cmd) {
    type = cmd.type.name;

    if (cmd.hasToNode()) {
      node = PackedGraphNode.chart(cmd.toNode);
    }

    if (cmd.hasFromNode()) {
      if (type == "remove") {
        node = PackedGraphNode.chart(cmd.fromNode);
      } else {
        last = PackedGraphNode.chart(cmd.fromNode);
      }
    }
  }

  GraphNodeCommand.add(GraphNode node) {
    type = "add";
    this.node = node.pack();
    node.last = this.node;
  }

  GraphNodeCommand.remove(GraphNode node) {
    type = "remove";
    this.node = node.pack();
    node.last = this.node;
  }

  GraphNodeCommand.update(GraphNode node) {
    type = "remove";

    this.node = node.pack();
    this.last = node.last;
    node.last = this.node;
  }

  @override
  String get name => "$type-node";

  @override
  GraphCommand get reverse {
    return GraphNodeCommand()
      ..type = type == "add" ? "remove" : "add"
      ..node = node
      ..version = version;
  }

  Map<String, dynamic> toJson() {
    var result = super.toJson();
    result.addAll({
      "node": node,
      "type": type,
    });

    return result;
  }

  @override
  TideChartCommand toChart() {
    TideChartCommand result = super.toChart();
    result.node = TideChartNodeCommand()..type = toUpdateType(type);

    if (type == "add") {
      result.node.toNode = node.toChart();
    } else if (type == "remove") {
      result.node.fromNode = node.toChart();
    } else {
      var changes = node.toChanges(last);
      result.node.fromNode = changes.first;
      result.node.toNode = changes.last;
    }

    return result;
  }
}

class GraphLinkCommand extends GraphCommand {
  String type;

  PackedGraphLink link;
  PackedGraphLink last;

  GraphLinkCommand();
  GraphLinkCommand.chart(TideChartLinkCommand cmd) {
    type = cmd.type.name;

    if (cmd.hasToLink()) {
      link = PackedGraphLink.chart(cmd.toLink);
    }

    if (cmd.hasFromLink()) {
      if (type == "remove") {
        link = PackedGraphLink.chart(cmd.fromLink);
      } else {
        last = PackedGraphLink.chart(cmd.fromLink);
      }
    }
  }

  GraphLinkCommand.add(GraphLink link) {
    type = "add";
    this.link = link.pack();
    link.last = this.link;
  }

  GraphLinkCommand.remove(GraphLink link) {
    type = "remove";
    this.link = link.pack();
    link.last = this.link;
  }

  GraphLinkCommand.update(GraphLink link) {
    type = "update";
    this.link = link.pack();
    this.last = link.last;
    link.last = this.link;
  }

  @override
  String get name => "$type-link";

  @override
  GraphCommand get reverse {
    return GraphLinkCommand()
      ..type = type == "add" ? "remove" : "add"
      ..link = link
      ..version = version;
  }

  Map<String, dynamic> toJson() {
    var result = super.toJson();
    result.addAll({
      "link": link,
      "type": type,
    });

    return result;
  }

  @override
  TideChartCommand toChart() {
    TideChartCommand result = super.toChart();

    result.link = TideChartLinkCommand()..type = toUpdateType(type);

    if (type == "add") {
      result.link.toLink = link.toChart();
    } else if (type == "remove") {
      result.link.fromLink = link.toChart();
    } else {
      var changes = link.toChanges(last);
      result.link.fromLink = changes.first;
      result.link.toLink = changes.last;
    }

    return result;
  }
}

class PackedGraph {
  String id;
  String name;
  String type;
  String title;
  String icon;
  List<PackedGraphNode> nodes = [];
  List<PackedGraphLink> links = [];
  GraphHistory history = GraphHistory();

  PackedGraph.graph(GraphState graph) {
    id = graph.id;
    name = graph.name;
    title = graph.title;
    icon = graph.icon;
    type = graph.type;
    nodes = [...graph.nodes.map((x) => x.pack())];
    links = [...graph.links.map((x) => x.pack())];
    history.version = graph.history.version;
    history.undoCmds = [...graph.history.undoCmds];
    history.redoCmds = [...graph.history.redoCmds];
  }

  PackedGraph.chart(TideChartGraph graph) {
    id = graph.id;
    name = graph.name;
    title = graph.title;
    icon = graph.icon;
    type = graph.type;

    nodes = [...graph.nodes.map((x) => PackedGraphNode.chart(x))];
    links = [...graph.links.map((x) => PackedGraphLink.chart(x))];
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'type': type,
        'name': name,
        'title': title,
        'icon': icon,
        'nodes': nodes,
        'links': links,
        'history': history.undoCmds,
      };

  TideChartGraph toChart() {
    TideChartGraph result = TideChartGraph();
    result.id = id;
    result.name = name;
    result.icon = icon;

    if (title != null) result.title = title;
    if (type != null) result.type = type;

    result.nodes.addAll(nodes.map((x) => x.toChart()));
    result.links.addAll(links.map((x) => x.toChart()));
    result.history.addAll(history.undoCmds.map((x) => x.toChart()));
    return result;
  }
}

class PackedGraphLink {
  PackedNodePort outPort;
  PackedNodePort inPort;
  int group = 0;

  PackedGraphLink.link(GraphLink link) {
    outPort = link.outPort.pack();
    inPort = link.inPort.pack();
    group = link.group;
  }

  PackedGraphLink.chart(TideChartLink link) {
    outPort = PackedNodePort.named(link.outNode, link.outPort, "outport");
    inPort = PackedNodePort.named(link.inNode, link.inPort, "inport");
    group = link.group;
  }

  GraphLink unpack(GetNodeByName lookup) {
    return GraphLink()
      ..outPort = outPort.unpack(lookup)
      ..inPort = inPort.unpack(lookup)
      ..group = group;
  }

  Map<String, dynamic> toJson() => {
        'outNode': outPort.node.name,
        'outPort': outPort.name,
        'inNode': inPort.node.name,
        'inPort': inPort.name,
        'group': group,
      };

  List<TideChartLink> toChanges(PackedGraphLink last) {
    return [last.toChart(), this.toChart()];
  }

  TideChartLink toChart() {
    TideChartLink result = TideChartLink();
    result.outNode = outPort.node.name;
    result.outPort = outPort.name;
    result.inNode = inPort.node.name;
    result.inPort = inPort.name;
    result.group = group;
    return result;
  }
}


class PackedNodePort {
  NodePortType type;
  RefGraphNode node;
  String name;
  int ordinal = 0;
  bool isDefault = false;

  PackedNodePort.port(NodePort port) {
    type = port.type;
    node = port.node.ref();
    name = port.name;
    ordinal = port.ordinal;
    isDefault = port.isDefault;
  }

  PackedNodePort.chart(TideChartPort port) {
    this.type =
        port.type == "inport" ? NodePortType.inport : NodePortType.outport;
    this.node = RefGraphNode()..name = port.node;
    name = port.name;
    ordinal = port.ordinal;
    isDefault = port.isDefault;
  }

  PackedNodePort.named(String node, String name, String type) {
    this.type = type == "inport" ? NodePortType.inport : NodePortType.outport;
    this.node = RefGraphNode()..name = node;
    this.name = name;
  }

  Map<String, dynamic> toJson() => {
        'type': type.toString().split(".").last,
        'node': node.name,
        'name': name,
        'ordinal': ordinal,
        'isDefault': isDefault
      };

  List<TideChartPort> toChanges(PackedNodePort last) {
    return [last.toChart(), this.toChart()];
  }

  TideChartPort toChart() {
    TideChartPort result = TideChartPort();
    result.type = type.toString().split(".").last;
    result.node = node.name;
    result.name = name;
    result.ordinal = ordinal;
    result.isDefault = isDefault;
    return result;
  }
}


class PackedGraphNode {
  GraphNodeType type = GraphNodeType.action;

  Offset pos;

  String name;
  String title;
  String icon;
  String method;
  String library;
  String comment;

  bool isLogging = false;
  bool isDebugging = false;
  bool isPaused = false;
  bool isDisabled = false;

  double delay = 0;

  List<PackedNodePort> inports = [];
  List<PackedNodePort> outports = [];

  PackedGraphNode.node(GraphNode node) {
    pos = node.pos;
    type = node.type;
    name = node.name;
    title = node.title;
    icon = node.icon;
    method = node.method;
    library = node.library;

    isLogging = node.isLogging;
    isDebugging = node.isDebugging;
    isPaused = node.isPaused;
    isDisabled = node.isDisabled;

    delay = node.delay;

    inports = [...node.inports.map((x) => x.pack())];
    outports = [...node.outports.map((x) => x.pack())];
  }

  PackedGraphNode.chart(TideChartNode node) {
    pos = Offset(node.posX.toDouble(), node.posY.toDouble());
    type = GraphNode.parseNodeType(node.type);
    name = node.name;
    title = node.title;
    icon = node.icon;
    method = node.method;
    library = node.library;

    isLogging = node.isLogging;
    isDebugging = node.isDebugging;
    isPaused = node.isPaused;
    isDisabled = node.isDisabled;

    delay = node.delay / 100.0;

    inports = [...node.inports.map((x) => PackedNodePort.chart(x))];
    outports = [...node.outports.map((x) => PackedNodePort.chart(x))];
  }

  Map<String, dynamic> toJson() => {
        'type': type.toString().split(".").last,
        'name': name,
        'title': title,
        'icon': icon,
        'method': method,
        'library': library,
        'isLogging': isLogging,
        'isDebugging': isDebugging,
        'isPaused': isPaused,
        'isDisabled': isDisabled,
        'delay': delay,
        'inports': inports,
        'outports': outports,
        'pos': [pos.dx, pos.dy],
      };

  List<TideChartNode> toChanges(PackedGraphNode last) {
    return [last.toChart(), this.toChart()];
  }

  TideChartNode toChart() {
    TideChartNode result = TideChartNode();
    result.type = type.toString().split(".").last;
    result.name = name;
    result.icon = icon;

    if (title != null) result.title = title;
    if (method != null) result.method = method;
    if (library != null) result.library = library;

    result.isLogging = isLogging;
    result.isDebugging = isDebugging;
    result.isPaused = isPaused;
    result.isDisabled = isDisabled;

    result.posX = pos.dx.round();
    result.posY = pos.dy.round();

    result.delay = (delay * 100).round();

    result.inports.addAll(inports.map((x) => x.toChart()));
    result.outports.addAll(outports.map((x) => x.toChart()));

    return result;
  }
}
