import "dart:io";
import 'package:xml/xml.dart' as xml;

var libraryName = "";
var className = "SourceSansProFont";

Map<String, String> paths = {};
Map<String, String> widths = {};
Map<int, String> codepointsByIndex = {};
Map<String, int> codepointsByName = {};

Map<String, String> fontface = {};

List<String> names = [];
var allowed =
    r"ABCČĆDĐEFGHIJKLMNOPQRSŠTUVWXYZŽabcčćdđefghijklmnopqrsštuvwxyzžАБВГҐДЂЕЁЄЖЗЅИІЇЙЈКЛЉМНЊОПРСТЋУЎФХЦЧЏШЩЪЫЬЭЮЯабвгґдђеёєжзѕиіїйјклљмнњопрстћуўфхцчџшщъыьэюяΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρστυφχψωάΆέΈέΉίϊΐΊόΌύΰϋΎΫὰάὲέὴήὶίὸόὺύὼώΏĂÂÊÔƠƯăâêôơư1234567890‘?’“!”(%)[#]{@}/&\<-+÷×=>®©$€£¥¢:;,.*";

void main(List<String> arguments) {
  var file = File(arguments.first);

  if (!file.existsSync()) {
    print('Cannot find the file "${arguments.first}".');
  }

  className = file.path.split(".").first.replaceAll("-", "") + "Font";

  var doc = xml.parse(file.readAsStringSync());
  var ff = doc.findAllElements("font-face").first;
  for (var attr in ff.attributes) {
    fontface[attr.name.toString()] = attr.value;
  }
  var glyphs = doc.findAllElements("glyph");
  var allowedCodepoints =
      allowed.isEmpty ? Set<int>() : allowed.codeUnits.toSet();

  for (var g in glyphs) {
    String name;
    String path;
    String width = "0";
    String unicode;

    for (var attr in g.attributes) {
      var x = attr.toString();
      var parts = x.split("=");
      var value = parts[1].replaceAll('"', '');

      if (parts[0] == "glyph-name") {
        name = value;
      } else if (parts[0] == "unicode") {
        unicode = value;
      } else if (parts[0] == "d") {
        path = attr.value;
        path = path.replaceAll("\n", " ");
      } else if (parts[0] == "horiz-adv-x") {
        width = value;
      }
    }
    if (path == null || unicode == null || unicode.isEmpty) continue;
    if (unicode.codeUnits.length > 1) continue;

    var cp = unicode.codeUnits.first;
    if (allowedCodepoints.isNotEmpty) {
      if (!allowedCodepoints.contains(cp)) {
        continue;
      }
    }

    codepointsByIndex[cp] = name;
    codepointsByName[name] = cp;
    paths[name] = path;
    widths[name] = width;

    names.add(name);
  }

  if (allowedCodepoints.isNotEmpty) {
    print(
        "Found ${names.length} of ${allowedCodepoints.length} allowed glyphs");
  } else {
    print("Found ${names.length} glyphs");
  }

  var outfile = file.path.replaceAll(".svg", ".txt");
  print("Writing $outfile");

  List<String> generatedOutput = [
    if (libraryName != null && libraryName.isNotEmpty) 'library $libraryName;',
    '',
    "import 'vector_font.dart';"
        '',
    '// THIS FILE IS AUTOMATICALLY GENERATED!',
    '',
    '// File generated using generate_icons.dart from the Flutter icons.dart.',
    '',
    'class $className extends VectorFontGlyphProvider {',
    '',
  ];

  generatedOutput.addAll(generateFontFace());
  generatedOutput.addAll(generateGlyphData());

  generatedOutput.addAll(generateStringAccess());
  generatedOutput.addAll(['', '}']);

  File output = File(outfile);
  output.writeAsStringSync(generatedOutput.join('\n'));
}

Iterable<String> generateGlyphData() sync* {
  yield '';

  var keys = codepointsByIndex.keys.toList();
  keys.sort();

  yield 'static VectorFontGlyph glyph_undefined = VectorFontGlyph("", 0, "");';

  for (var cp in keys) {
    var name = codepointsByIndex[cp];
    var path = paths[name];
    var width = widths[name];

    yield 'static VectorFontGlyph glyph_$cp = VectorFontGlyph("$name", $width, "$path");';
  }

  yield '';
}

Iterable<String> generateFontFace() sync* {
  yield '';
  yield 'Map<String,String> getFontFace() {';
  yield 'return {';

  for (var key in fontface.keys) {
    yield '"$key":"${fontface[key]}",';
  }

  yield '};';
  yield '}';
  yield '';
}

Iterable<String> generateStringAccess() sync* {
  yield '';
  yield 'VectorFontGlyph getGlyph(int codepoint) {';
  yield 'switch (codepoint) {';

  var keys = codepointsByIndex.keys.toList();
  keys.sort();

  for (var cp in keys) {
    yield 'case $cp:';
    yield 'return glyph_$cp;';
  }

  yield 'default:';
  yield 'return glyph_undefined;';

  yield '}';
  yield '}';
  yield '';
}

Iterable<String> generateIntegerAccess() sync* {
  yield '';
  yield 'List<String> names = [';
  for (var name in names) {
    yield '"$name",';
  }
  yield '];';
  yield '';
}
